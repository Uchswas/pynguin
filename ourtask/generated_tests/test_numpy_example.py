# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import numpy_example as module_0
import pandas.core.computation.expressions as module_1
import numpy.ma.extras as module_2
import pandas.io.formats.console as module_3
import pandas.core.computation.expr as module_4


def test_case_0():
    none_type_0 = None
    var_0 = module_0.dataframe_operations(
        none_type_0, threshold=none_type_0, column=none_type_0
    )


@pytest.mark.xfail(strict=True)
def test_case_1():
    none_type_0 = None
    var_0 = module_0.dataframe_operations(
        none_type_0, threshold=none_type_0, column=none_type_0
    )
    var_1 = module_0.dataframe_operations(none_type_0)
    module_0.dataframe_operations(none_type_0, var_0, var_0)


def test_case_2():
    bool_0 = True
    list_0 = [bool_0, bool_0]
    var_0 = module_0.dataframe_operations(list_0, list_0)
    none_type_0 = None
    var_1 = module_0.dataframe_operations(
        none_type_0, threshold=none_type_0, column=none_type_0
    )


def test_case_3():
    none_type_0 = None
    var_0 = module_0.dataframe_operations(none_type_0, none_type_0, none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_4():
    none_type_0 = None
    list_0 = module_1.get_test_result()
    assert (
        f"{type(module_1.annotations).__module__}.{type(module_1.annotations).__qualname__}"
        == "__future__._Feature"
    )
    assert module_1.annotations.optional == (3, 7, 0, "beta", 1)
    assert module_1.annotations.mandatory == (3, 11, 0, "alpha", 0)
    assert module_1.annotations.compiler_flag == 16777216
    assert module_1.TYPE_CHECKING is False
    assert module_1.NUMEXPR_INSTALLED is False
    assert module_1.USE_NUMEXPR is False
    var_0 = module_0.dataframe_operations(list_0, column=list_0)
    var_1 = module_0.dataframe_operations(list_0, none_type_0, list_0)
    module_0.dataframe_operations(none_type_0, threshold=var_0, column=var_0)


@pytest.mark.xfail(strict=True)
def test_case_5():
    none_type_0 = None
    var_0 = module_2.clump_masked(none_type_0)
    assert (
        f"{type(module_2.masked).__module__}.{type(module_2.masked).__qualname__}"
        == "numpy.ma.core.MaskedConstant"
    )
    assert (
        f"{type(module_2.nomask).__module__}.{type(module_2.nomask).__qualname__}"
        == "numpy.bool"
    )
    assert (
        f"{type(module_2.mr_).__module__}.{type(module_2.mr_).__qualname__}"
        == "numpy.ma.extras.mr_class"
    )
    assert len(module_2.mr_) == 0
    var_1 = module_0.dataframe_operations(var_0, threshold=var_0)
    var_0.transform()


@pytest.mark.xfail(strict=True)
def test_case_6():
    none_type_0 = None
    var_0 = module_3.get_console_size()
    assert (
        f"{type(module_3.annotations).__module__}.{type(module_3.annotations).__qualname__}"
        == "__future__._Feature"
    )
    assert module_3.annotations.optional == (3, 7, 0, "beta", 1)
    assert module_3.annotations.mandatory == (3, 11, 0, "alpha", 0)
    assert module_3.annotations.compiler_flag == 16777216
    var_1 = module_0.dataframe_operations(var_0, column=var_0)
    var_1.interpolate(limit=none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_7():
    list_0 = module_1.get_test_result()
    assert (
        f"{type(module_1.annotations).__module__}.{type(module_1.annotations).__qualname__}"
        == "__future__._Feature"
    )
    assert module_1.annotations.optional == (3, 7, 0, "beta", 1)
    assert module_1.annotations.mandatory == (3, 11, 0, "alpha", 0)
    assert module_1.annotations.compiler_flag == 16777216
    assert module_1.TYPE_CHECKING is False
    assert module_1.NUMEXPR_INSTALLED is False
    assert module_1.USE_NUMEXPR is False
    var_0 = module_0.dataframe_operations(list_0, column=list_0)
    var_1 = module_0.dataframe_operations(list_0, column=list_0)
    var_2 = module_0.dataframe_operations(list_0)
    var_3 = module_0.dataframe_operations(list_0, list_0, column=var_1)
    var_4 = module_4.add_ops(var_3)
    assert (
        f"{type(module_4.annotations).__module__}.{type(module_4.annotations).__qualname__}"
        == "__future__._Feature"
    )
    assert module_4.annotations.optional == (3, 7, 0, "beta", 1)
    assert module_4.annotations.mandatory == (3, 11, 0, "alpha", 0)
    assert module_4.annotations.compiler_flag == 16777216
    assert module_4.ARITH_OPS_SYMS == ("+", "-", "*", "/", "**", "//", "%")
    assert module_4.BOOL_OPS_SYMS == ("&", "|", "and", "or")
    assert module_4.CMP_OPS_SYMS == (">", "<", ">=", "<=", "==", "!=", "in", "not in")
    assert module_4.LOCAL_TAG == "__pd_eval_local_"
    assert module_4.MATHOPS == (
        "sin",
        "cos",
        "exp",
        "log",
        "expm1",
        "log1p",
        "sqrt",
        "sinh",
        "cosh",
        "tanh",
        "arcsin",
        "arccos",
        "arctan",
        "arccosh",
        "arcsinh",
        "arctanh",
        "abs",
        "log10",
        "floor",
        "ceil",
        "arctan2",
    )
    assert module_4.REDUCTIONS == ("sum", "prod", "min", "max")
    assert module_4.UNARY_OPS_SYMS == ("+", "-", "~", "not")
    assert (
        f"{type(module_4.intersection).__module__}.{type(module_4.intersection).__qualname__}"
        == "builtins.frozenset"
    )
    assert len(module_4.intersection) == 0
    assert (
        f"{type(module_4.PARSERS).__module__}.{type(module_4.PARSERS).__qualname__}"
        == "builtins.dict"
    )
    assert len(module_4.PARSERS) == 2
    module_0.dataframe_operations(var_3, var_4, list_0, var_4)
